day01

1. 名字空间 、 命名空间 （name space）

2. 任何基本类型的数据都可以隐式转换（编译器帮我们转换）布尔类型
    复合类型如何转换为布尔 ?????????????????????

3. 自定义转换（第四天下午会讲）

4. C++国际标准规定全天下的C++编译器都要对函数进行换名, 但是换名的规则都不一样
    int sum(int,int);
    g++   : _Z3sumii
    cl.exe : ?sumYAHHH@Z
    ....

day02:
1. 赠送
     int a[4];    首元素地址类型为 int* ;
                     首地址类型：    int(*)[4]；

     数组名二义性 : 在绝大多数情况中代表数组首元素地址，在2种情况下代表整个数组（sizeof / &）

     &a : int(*)[4]

     不管几维数组，在分析时都应该当做一维数组看待
     int b[3][4];
     b : 如果代表首元素地址  int(*)[4]

2. 异常处理( 第8天下午讲 )
     try {
          new int[0xFFFFFFFFFFFFFFF];
     }
     catch( ... ) {  
     }

3. 左值 和 右值
    左值 : 能够取地址  &
    右值 : 不能取地址   

4. 常引用就是万能引用（可以引用 非常左值、常左值，右值 ）
    常指针就是万能指针（可以指向 非常左值、常左值、右值）
     int a = 10;
     const int& cra = a; // 但是常引用 如果引用的是非常左值， 通过常引用将丧失修改目标内存的权限
     const int* cpa = &a; // 但是常指针如果指向的是非常左值，通过常指针将丧失修改目标内存的权限

5. C语言中的数据传递（初始化，赋值，传参，返回值） 都是 值传递（将数据复制一份给别人）
   void foo( int v ) {...}
   int bar() {
       int m=100;
       return m;
   }
   int  main() {
       int a = 10; // 初始化
       a = 30; // 赋值
       foo( a ); // 传参
       |100| bar(); // 返回值
   }
   因为C++语言有引用这个技术，可以不做值传递

6. 动态类型转换（第八天上午）
7. 静态类型转换的第二个应用场景：自定义类型转换（第四天下午讲）

8. 面向对象

人构成团队
              调研报告                    需求分析报告             代码                     测试报告
产品经理------------需求分析师--------------程序员-------------测试人员----------


大型软件
                     接收的数据                   解压后数据                 明文数据                          处理后的数据                密文数据
接收数据对象--------------解压缩对象--------------解密对象--------------处理数据对象-----------------加密对象------------压缩对象

   压缩后的数据
------------------发送数据对象


9. C语言处理问题，分而治之（面向问题域 拆）

a+b-c*(d + e)/f ;
a*b/c+d*e-f;

    C++语言处理问题，大处着眼

a+b-c*(d + e)/f ;
计算器
a*b/c+d*e-f;

day03:

1.抽象事物：抽取事物的特征
2.类的作用：抽取事物特征的规则
   类在代码中落地时，是一种复合的数据类型（例如：结构体）


                                                                 规则(类)
狗--------------------------------你-----------------------------计算机（内存建立狗的影像）
                                                                  犬种                     藏獒
                                                                  犬龄                        2
                                                                  体重                     150
                                                                  毛色                      黑白花色
                                                                  长相                      大脑袋，大耳朵，红鼻子头，毛茸茸大尾巴...

3. 定义xxx : 就是xxx分配内存空间     

4. 哪个对象调用成员函数，成员函数的this参数 就指向哪个对象****************************************************            

5. 对象 和 函数
    非常对象优先选择 非常函数 也能选择 常函数( 不挑食 )
    常对象只能选择 常函数 不能选择 非常函数( 很挑食 )         

6. 全天下类型转换都会产生 匿名对象

7. 构造函数的作用 ： 定义对象的各个成员变量(造包子馅)***********************************************************

8. string类对象定义的5种方法

     string s1("hello");               //定义s1,利用s1.string("hello")->s1维护的字符串为"hello"
    
      string s2 = s1; //(s1)      //定义s2,利用s2.string(s1)->s2维护的字符串 和 s1维护的字符串 内容相同
  
      string s3; // 定义s3,利用s3.string()->s3维护的字符串为"\0"
      s3 = s2; // s3.operator=(s2)-->s3维护的字符串 和 s2维护的字符串 内容相同
     
      string s4="hello";  // ---> s4维护的字符串为"hello"
  
      string s5;
      s5 = "hello";  //--->s5维护的字符串为"hello"

9. 注意事项：（适用于所有类）
    如果在做初始化,并且"="两边类型完全一致,那么=xxx和(xxx)无差别
    如果在做赋值,并且"="两边类型完全一致,将触发operator=（拷贝赋值）函数的调用
    无论初始化还是赋值,只要"="两边类型不一致,首先都要类型转换

day04：
 1. 我和大家的君子协议

    【....】- 在this指针所指向的内存空间中

2. 为啥标准的string类对象可以直接交给cout打印，而我们String类对象不行????????????????????????????????


day05:
1. 操作符重载：就是为了解决让我们类型和 基本类型 一样 可以参与 各种 运算符的表达式

2. 在c语言中 
    前++：先加1，再使用
    后++：先使用，再加1

    在C++语言中，不管是前++还是后++，都是直接加1，但是还想让用户感觉和C一样。

3. 模拟实现C++标准库中ostream类( 仅仅是模拟和真正ostream类的实现不同，但是道理完全一样 )
class ostream {
     operator<<( int/double/float/short....  data ) { // 有大量operator<<函数，形参都不同
      }
      operator<<( Human ... ) {} // 肯定没有形参为Human的operator<<函数，绝对不让我们添加
};
// 以上代码模拟C++标准库
// ----------------------------
// 以下代码模拟用户
int main() {
   string str = "fdsfds";
   cout << str;
   Human h;
   cout << h; // cout.operator<<(h) // -->实参类型为Human  或 operator<<(cout,h)

   int a;  double b;    float c;    short d;   ....
   const int ca;  const double cb;    const float cc;    const short cd;   ....
   cout << a;  // cout.operator<<(a)-->实参类型为int
   cout << b;  // cout.operator<<(b)-->实参类型为double
   cout << c;  // cout.operator<<(c)-->实参类型为float
   cout << d; // cout.operator<<(d)-->实参类型为short
   cout << '\n'; // cout.operator<<('\n')-->实参类型为char
   cout << ca;  // cout.operator<<(ca)-->实参类型为const int
   cout << cb; // cout.operator<<(cb)-->实参类型为const double
   cout << cc; // cout.operator<<(cc)-->实参类型为const float
   cout << cd; // cout.operator<<(cd)-->实参类型为const short
   cout << "hello"; // cout.operator<<("hello")-->实参类型为const char*
}

day06:
1. C++语言的一个思想: 一个对象中包含了xxx, 我们就拿这个对象当xxx来用

2.  继承最基本的特点(三种继承方式中是相同的):
   (1) 子类对象 内部包含 基类(子)对象
   (2) 子类内部 可以直接访问 基类的非私有(公有/保护)成员(变量/函数)
   (3) 子类 与 基类 的同名表示符 为隐藏关系 ( 除了虚函数以外 ????????? )

3.  公有继承独有特点:
   (1) 只有在公有继承下，子类对象在类外 可以访问基类的公有成员(其他继承不可以)， 如果被子类同名表示符隐藏，可以借助作用域限定符指明访问基类的
 （2）只有在公有继承下，子类类型指针 和 基类类型指针 之间可以进行转换
                                       子类类型引用 和 基类类型引用 之间可以进行转换
                                       其它继承方式不可以


4. 为什么指针需要类型? 答：指针类型决定它的 眼界(*) 和 步长(+1)

5.  向上造型
     Human* ph = &s; // 子类类型指针 隐式转换为 基类类型指针
     Human& rh = s; // 子类类型引用 隐式转换为 基类类型引用
      // 以上两种转换,编译器认为访问范围缩小,是安全的.

6.  几种Human类对象

      Human h; // 定义h,利用h.Human() --> 维护的内容 （无名, 0）
       
      Human h2(22,"张飞"); // 定义h2,利用h2.Human(22,"张飞")-->维护的内容（张飞,22）
      
      Human h3(h2); //= h2; 定义h3,利用h3.Human(h2) --> h3维护的内容 和 h2维护的内容 相同
    
      Human h4; // 定义h4,利用h4.Human() --> 维护的内容 （无名, 0） 
      h4 = h3; // h4.operator=(h3) // ->h4维护的内容 和 h3维护的内容 想通
     

day07：
1. 基类和子类的 相同原型的虚函数 - 覆盖关系？？？？？？？？？？？？？？？
    基类和子类的 相同原型的普通函数 - 隐藏关系

2. 多态的要件？
   1. 基类 必须 要有虚函数，子类 必须 提供覆盖版本
   2. 必须利用 基类类型指针( 必须指向子类对象 ) 调用 虚函数
       必须利用 基类类型引用( 必须引用子类对象 ) 调用 虚函数

3. 多态的结果？
        最终调用的为 子类覆盖版本虚函数，而非基类原始版本虚函数

day08:

1. 动态类型转换在转换引用失败时，会抛出bad_cast异常?????????????????????????????

2. 如果程序中没有捕获异常的代码，异常一旦抛出，我们的程序将被操作系统杀死。
    
    如果程序中有捕获异常的代码，异常一旦抛出, 层层退出右花括号，直到异常被捕获为止。程序正常流程。


class Stack {
public:
     Stack() {}
     void push( int data ) throw(overflow_error) {
          if( size==20 )
                throw overflow_error("满了");
          arr[size++] = data;
      }
      int pop() throw(underflow_error) {
           if( size==0 )
                 throw underflow_error("空了");
           return arr[--size];
      }
private:
     int arr[20];
     int size;
};

void foo( int x ) throw(invalid_argument) {
     if( x<0 )
          throw invalid_argument("参数不符合要求");
     .......
}

// 以上代码模拟容器设计者
// ------------------------ 
// 以下代码模拟用户
int main() {
   try {
       foo(-100);
   }
   catch( invalid_argument& e ) {
      ....
   }


    Stack s;
    try {
       s.pop();
    }
    catch( underflow_error& e ) {
         ....
    }
}

3. 如何将 类对象 转换为 bool  -- 需要利用 类型转换操作符函数

    C++语言经常将 类对象 放置在 布尔上下文中（if语句的判定条件，while循环的判定条件，for循环的第二个判定条件，利用类对象给bool变量初始化，利用类对象给bool赋值，
                                                                             逻辑反）, 一旦这种现象出现 需要将 类对象 转换为 布尔类型

day09:

1. C++的IO流操作，经常将 流对象 放置在bool上下文，来判断上一步IO操作( 例如：创建、打开、写、读文件，设置文件指针位置 等等.. )是否成功

2. 模拟实现ifstream类，仅仅是模拟，和真正ifstream类的实现不同，但是道理一样
class ifstream {
public:
       ifstream( const char* path, ... ) {
             if( m_s == ios::goodbit )  {                  
                 m_f = open(path, ...);
                 if( m_f == -1 ) 
                      m_s = ios::failbit; // 4
                 else
                      m_s = ios::goodbit; // 0
            }
       }
       operator bool() const {
              return m_s == ios::goodbit; // 0
       }
       istream& operator>>(int/double/string/short/float.... ) { // 有大量的operator>>函数形参都不相同
               if( m_s != 0 )
                   return ...;
	        int ret = read( m_f, ...... );
               if( ret==-1 ) 
                    m_s = ios::failbit; // 4
               else
                    m_s = ios::goodbit; // 0
       }
private:
        int m_f; // 保存文件描述符
        int m_s; // 保存状态值
}；
// 以上代码模拟标准库
// -------------------------------
// 以下代码模拟用户
  int main( void ) {
      ifstream ifs2("./ofs", ios::ate);
      if( !ifs2 ) { // ! ifs2.operator bool()
          cerr << "ifs2流对象状态错误--打开文件失败" << endl;
     }
      int ii; double dd;  string ss1, ss2;     
      ifs2 >> ii >> dd >> ss1 >> ss2; // ifs2.operator>>(ii).operator>>(dd).operator>>(ss1)....
      if( !ifs2 ) { // ! ifs2.operator bool()
          cerr << "ifs2流对象状态错误--读文件失败" << endl;
      }

}


day10:

  Human h; // 定义h,利用h.Human()

  h[i]; // h.operator[](i) --> 下标操作符 函数

  h(i,j,k); // h.operator()(i,j,k) --> 函数操作符 函数


day11:
  类型形参表中 可以出现三种类型的形参   （1）类型形参    (2) 数值型形参   (3) 类模板


day12：

 1. 非常迭代类的对象 -- 非常迭代器（和迭代器本身有无常属性无关）专门操作非常容器

     常迭代类的对象 -- 常迭代器（和迭代器本身有无常属性无关）专门操作常容器

2. STL - Standard Template Library( 标准模板库 )

3. 计算机存储数据的结构只有  顺序存储   和  链式存储   两种最基本结构

4. 线性容器（基本容器）
    向量(维护连续内存空间)、双端队列(连续内存空间)、列表(链式内存空间)

5. 适配（裁剪）器容器
     栈、队列、优先队列

6. 关联容器
    映射(平衡有序二叉树)、多重映射、集合、多重集合

7. 无序容器
    无序映射( 哈希散列表 )

8. 所有容器 保存的都是 数据的副本

day13:
有序二叉树
5 4 3 2 1
        5
      4
    3
  2
1

平衡有序二叉树（红黑树）
5 4 3 2 1
     
    3   
  2  4
1      5


哈希算法-------哈希散列表-----------无序映射
(数学算法)        (数据结构)                 （容器）

哈希算法：
"gersfdsfsdfdsfs"     98
"gersfdsfsdfdsfd"     213
"fsdjflsdjfsdlfgjsdklfjsdlfjdskl"   18

哈希散列表

处理哈希值  对 10 取余
"gersfdsfsdfdsfs" ---> 98 --> 98%10 --> 8
"gersfdsfsdfdsfd"--->213 --> 213%10-->3
"fsdjflsdjfsdlfgjsdklfjsdlfjdskl" --->18 -->18%10-->8

0|*|-->|...|-->|...|-->|...|
1|*|-->|...|-->|...|-->|...|-->|...|-->|...|-->|...|
2|*|-->|...|-->|...|-->|...|-->|...|-->|...|
3|*|-->|213 "gersfdsfsdfdsfd"|
4|*|-->|...|-->|...|-->|...|
5|*|-->|...|-->|...|-->|...|-->|...|-->|...|-->|...|
6|*|-->|...|-->|...|-->|...|-->|...|
7|*|-->|...|-->|...|-->|...|-->|...|-->|...|-->|...|-->|...|
8|*|-->|98 "gersfdsfsdfdsfs"|-->|18 "fsdjflsdjfsdlfgjsdklfjsdlfjdskl"|
9|*|-->|...|-->|...|-->|...|

查找
"fsdjflsdjfsdlfgjsdklfjsdlfjdskl"-->18-->18%10-->8


















